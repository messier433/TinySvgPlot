function num2eng (val) {
    const unitList = ['y', 'z', 'a', 'f', 'p', 'n', 'u', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
    const zeroIndex = 8;
    var out = Array(val.length);
    for(idx = 0; idx < val.length; ++idx) {
        const nn = val[idx].toExponential(5).split(/e/);
        let u = Math.floor(+nn[1] / 3) + zeroIndex;
        if (u > unitList.length - 1) {
        u = unitList.length - 1;
        } else
        if (u < 0) {
        u = 0;
        }
        out[idx] =  (nn[0] * Math.pow(10, +nn[1] - (u - zeroIndex) * 3)) + unitList[u];
    }
    return out;
}
function linspace (start, increment, stop) {
    numel = Math.floor((stop-start)/increment)+1;
    out = Array(numel);

    for(idx=0,val =start; val <= stop; ++idx,val+=increment){
        out[idx] = val;
    }
    return out;
}

function logspace (start, increment, stop) {
    numel = Math.floor((stop-start)/increment)+1;
    out = Array(numel);

    for(idx=0,val =start; val <= stop; ++idx,val+=increment){
        out[idx] = Math.log10(val);
    }
    return out;
}

function decades (start, increment, stop) {
    numel = Math.floor((stop-start)/increment)+1;
    out = Array(numel);

    for(idx=0,val =start; val <= stop; ++idx,val+=increment){
        out[idx] = Math.pow(10,val);
    }
    return out;
}

function createSVGElement(ele, attrs) {
    const ns = "http://www.w3.org/2000/svg";
    //create the element with a specified string:
    var element = document.createElementNS(ns, ele);

    //create a for...in loop set attributes:
    for (let val in attrs) {
        element.setAttribute( val, attrs[val]);          
    }
    //return the element with the set attributes:
    return element;
}
function appendSvgText(parent, text, x, y, fontsize, textanchor = "middle", fontfamily="Sans,Arial") {
    var textEl = createSVGElement("text", {"x":x, "y":y,
            "fill":"black", "font-size":fontsize, "text-anchor":textanchor, "font-family":fontfamily,
            "stroke-width": 1
            });
    textEl.append(document.createTextNode(text));              
    parent.appendChild(textEl);
    return textEl;
}
function appendSvgLine(parent, x1, y1, x2,y2, stroke="black", strokedasharray="") {
    var lineEl = createSVGElement("line", {"x1":x1, "y1":y1,"x2":x2, "y2":y2,
            "stroke":stroke, "stroke-width": 1, "stroke-dasharray": strokedasharray
    });  
    parent.appendChild(lineEl);
    return lineEl;
};

function toggleLineVisibility(lineIdx, numLines) {
    var style = document.getElementById("pl_"+lineIdx).style.display;
    if(numLines == 0) {
        if (style === "none") {
            document.getElementById("pl_"+lineIdx).style.display = "block";
            document.getElementById("lli_"+lineIdx).style.opacity = 1;
            document.getElementById("lti_"+lineIdx).style.opacity = 1;
        } else {        
            document.getElementById("pl_"+lineIdx).style.display = "none";
            document.getElementById("lli_"+lineIdx).style.opacity = 0.3;
            document.getElementById("lti_"+lineIdx).style.opacity = 0.3;
        }
    } else {
        for(idx = 0; idx < numLines; ++idx) {
            if (style === "none") { // make all visible again
                console.log("none");
                document.getElementById("pl_"+idx).style.display = "block";
                document.getElementById("lli_"+idx).style.opacity = 1;
                document.getElementById("lti_"+idx).style.opacity = 1;
            } else  if(idx != lineIdx) { // only keep selected one visible
                console.log("block");
                document.getElementById("pl_"+idx).style.display = "none";
                document.getElementById("lli_"+idx).style.opacity = 0.3;
                document.getElementById("lti_"+idx).style.opacity = 0.3;
            }
        };
    };
}

function removeInvalidPoints(pts) {
    var x = pts[0];
    var y = pts[1];

    var newX = Array(x.length);
    var newY = Array(y.length);

    if(x.length == y.length) {
        var newIdx = 0;
        for(idx = 0; idx < y.length; ++idx) {
        if(isFinite(x[idx]) && isFinite(y[idx])) {
            newX[newIdx] = x[idx];
            newY[newIdx] = y[idx];
            ++newIdx;
        };
        };
        if(newIdx < x.length) {
        newX = newX.slice(0, newIdx);
        newY = newY.slice(0, newIdx);
        };
    } else {
        var newIdx = 0;
        var numLines = y.length/x.length;
        var numPoints = x.length;
        for(idx = 0; idx < numPoints; ++idx) {
        var xValid = isFinite(x[idx]);
        var yValid = true;
        for(idxLines = 0; idxLines < numLines; ++idxLines) {
            if(!isFinite(y[idxLines*numPoints +  idx])) {
            yValid = false;
            break;
            };
            newY[idxLines*numPoints + newIdx] = y[idxLines*numPoints + idx];  
        };
        if(xValid && yValid) {
            newX[newIdx] = x[idx];          
            ++newIdx;
        };
        };
        if(newIdx < x.length) {
        newX = newX.slice(0, newIdx);
        newIdx = 0;
        for(idx = 0; idx < y.length; ++idx) {
            if((idx % numPoints) < newX.length) {
            newY[newIdx] = y[idx];
            ++newIdx;
            }
        }
        newY = newY.slice(0, newX.length*numLines);
        };
    }
    return [newX, newY];
}
function plotSvg(elementId, x, y, numLines, width, height, 
{title = "", subtitle = "", xlabel = "", ylabel="", xlim=[], ylim=[], 
    legend = [], xScale = "linear", yScale = "linear", grid = true, 
    gridMinor = [], legendLocation = 'northeast'
}={}
)
{      
    const ns = "http://www.w3.org/2000/svg";
    const axesLblFontSize = 12;
    const legendFontSize = 10;
    const legendFont = "Lucida Sans Typewriter"; // needs to be a monospace font!
    const legendLineLength = 20; // number of pixels for the line length in the legend
    const legendXSpacing = 4; // number of pixels between legend box, line and text
    const legendYSpacing = 4; // number of pixels between two entries
    const maxLegendWidth = width/4;
    const fontSpacing = 4;
    const titleFontSize = 24;
    const subTitleFontSize = 12;
    var nXTicks = 10; // max ticks (will be adjusted for short tick labels)
    var nYTicks = 10; // max ticks (will be adjusted for short tick labels)
    var nXMinorTicks = 10; // minor ticks  (max value; will be adjusted)
    var nYMinorTicks = 10; // minor ticks  (max value; will be adjusted)
    const normTicks = [1, 2, 5, 10];
    const xAxesSpacing = axesLblFontSize*5;
    const yAxesSpacing = axesLblFontSize*3;
    const colorMapRGB =  ["rgb(0,114,190)", "rgb(218,83,25)", "rgb(238,178,32)", 
                        "rgb(126,47,142)", "rgb(119,173,48)", "rgb(77,191,239)",
                        "rgb(163,20,47)"];

    logXEnbl = false;
    if(xScale == "log") {
        x.forEach((value, index) => {x[index] = Math.log10(value)});
        if(xlim.length > 1) {
        xlim = xlim.map(Math.log10);
        
        if (xlim[0] == NaN || xlim[1] == NaN) {
            xlim = [];
        };
        xlim[0] =  (xlim[0] == -Infinity) ? 0 : xlim[0];
        xlim[1] =  (xlim[1] == -Infinity) ? 0 : xlim[1];        
        };
        logXEnbl = true;
    };

    logYEnbl = false;
    if(yScale == "log") {
        y.forEach((value, index) => {y[index] = Math.log10(value)});
        if(ylim.length > 1) {
        ylim = ylim.map(Math.log10);
        if (ylim[0] == NaN || ylim[1] == NaN) {
            ylim = [];
        };
        ylim[0] =  (ylim[0] == -Infinity) ? 0 : ylim[0];
        ylim[1] =  (ylim[1] == -Infinity) ? 0 : ylim[1];  
        };
        logYEnbl = true;
    };

    // remove NAN and infinity
    newPts = removeInvalidPoints([x,y]);
    x = newPts[0];
    y = newPts[1];

    var el = document.getElementById(elementId) ;
    var svg = createSVGElement("svg", {"width": width, "height": height});
    el.appendChild(svg);

    // write styles
    svg.innerHTML += "\<style\>\n" +
        "\<![CDATA[\n" + 
        "  text.cll {\n" + 
        "    font-size:"+legendFontSize+"px;\n" + 
        "    fill:black;\n" + 
        "    dominant-baseline:middle;\n" + 
        "    font-family:"+legendFont+";\n" + 
        "  }\n" + 
        "]]\>\n" + 
        "\</style\>\n";


    var plotAreaYOffset = 0;
    var plotAreaXOffset = xAxesSpacing;
    ////////////////////////////////
    // Calc plot and legend area
    ////////////////////////////////
    const titleLines = title.split("\n");
    const subtitleLines = subtitle.split("\n");
    if(title.length>0) {        
        plotAreaYOffset += (titleFontSize + fontSpacing) * titleLines.length;
    };
    if(subtitle.length>0) {
        plotAreaYOffset += (subTitleFontSize + fontSpacing) * subtitleLines.length;
    };

    plotAreaYOffset = plotAreaYOffset + 10;

    var plotHeight = height-plotAreaYOffset-yAxesSpacing;
    var plotWidth = width-plotAreaXOffset-xAxesSpacing;

    // reserve space for labels
    if(xlabel.length>0) {
        plotHeight = plotHeight - axesLblFontSize - fontSpacing;
    };
    if(ylabel.length>0) {
        plotAreaXOffset= plotAreaXOffset + axesLblFontSize + fontSpacing;
        plotWidth = plotWidth - axesLblFontSize - fontSpacing;
    };

    //////////////////////////////////////
    // create legend
    //////////////////////////////////////
    // create group
    var gleg = createSVGElement("g");
    if(legend.length>0 && numLines > 0 && x.length > 0) {  
        var legFill = "";
        // set legend dimensions depending on location
        switch(legendLocation) {
            case 'northeast':
                yLegend = plotAreaYOffset + 2*legendYSpacing;
                hLegendMax = plotHeight - 4*legendYSpacing;
                legFill="white";
                break;
            case 'northeastoutside':
                yLegend = plotAreaYOffset;
                hLegendMax = plotHeight;
                legFill = "none";
                break;
            default:
                throw new Error("LegendLocation not supported");
        }
            
        var nLegend = legend.length > numLines ? numLines : legend.length; // cannot be more legend entries than lines
        legend = legend.slice(0,nLegend);    
        
        // get font size
        const hLetter = legendFontSize;  
        
        var hLegend = nLegend * (hLetter + legendYSpacing) + legendYSpacing;
        var legendTrunc = 0;
        if(hLegend > hLegendMax) {
            // reduce legend entries to fit into box
            nLegend = Math.floor((hLegendMax -legendYSpacing) / (hLetter + legendYSpacing)) - 1;
            legendTrunc = legend.length - nLegend;   
            legend = legend.slice(0,nLegend);  
            hLegend = (nLegend+1) * (hLetter + legendYSpacing) + legendYSpacing;
        }             
         

        // define legend line
        var defsll = createSVGElement("defs");
        svg.appendChild(defsll); 
        var ll = createSVGElement("line", {"id":"ll_"+elementId, "x1":0, "y1":0,"x2":legendLineLength,"y2":0, "stroke-width":1.5});
        defsll.appendChild(ll); 
    
        
        // draw legend box (change width later)
        var recleg = createSVGElement("rect", {"x":0,"y":0,"height":hLegend,
            "fill":legFill,"stroke":"black","stroke-width":1});
        gleg.appendChild(recleg); 
        
        var cpleg = createSVGElement("clipPath", {"id":"lBox_" + elementId});
        gleg.appendChild(cpleg); 
        var cprect = createSVGElement("rect", {"x":0,"y":0,"height":hLegend});
        cpleg.appendChild(cprect); 
    
        var gcpleg = createSVGElement("g", {"clip-path":"url(#lBox_" + elementId +")"});
        gleg.appendChild(gcpleg);
        
        // create legend items
        for(lineIdx = 0; lineIdx < legend.length; ++lineIdx) {
            colorIdx = lineIdx % colorMapRGB.length;
            yOffset = lineIdx * (hLetter + legendYSpacing) +  legendYSpacing;

             // legend lines
            var lineEl = createSVGElement("use", {"id": "lli_"+lineIdx, "x":legendXSpacing, "y":yOffset+hLetter/2,
                "href":"#ll_"+elementId, "stroke":colorMapRGB[colorIdx], 
                "onclick":"toggleLineVisibility(\""+lineIdx+"\", 0)",
                "ondblclick":"toggleLineVisibility(\""+lineIdx+"\"," + legend.length+")"
                });
                gcpleg.appendChild(lineEl);

            // legend labels
            var textEl = createSVGElement("text", {"id": "lti_"+lineIdx, "class":"cll", 
                "x":legendXSpacing+legendLineLength+legendXSpacing, "y":yOffset+hLetter/2, 
                "onclick":"toggleLineVisibility(\""+lineIdx+"\",0)",
                "ondblclick":"toggleLineVisibility(\""+lineIdx+"\"," + legend.length+")"
            });
            textEl.append(document.createTextNode(legend[lineIdx]));    
            gcpleg.appendChild(textEl);

        }
        
        if(legendTrunc) {
            yOffset = legend.length * (hLetter + legendYSpacing) +  legendYSpacing + hLetter/2;
            var textEl = createSVGElement("text", {"class":"cll", "x":legendLineLength+2*legendXSpacing,
                 "y":yOffset, "font-weight":"bold" });
            textEl.append(document.createTextNode("... (" + legendTrunc + " more)"));              
            gcpleg.appendChild(textEl);

        }

        // add legend already here to calculate width
        // will be moved again at the end of the function 
        svg.appendChild(gleg);        
        
        var bbox = gcpleg.getBBox();
        var wLegend = bbox.width + 2*legendXSpacing;

        wLegend = (wLegend > maxLegendWidth) ? maxLegendWidth : wLegend;
        // update width of legend rectangle and clip box
        recleg.setAttribute("width",wLegend);
        cprect.setAttribute("width",wLegend);

         // create bouding box for mouse clicks on legend items
         for(lineIdx = 0; lineIdx < legend.length; ++lineIdx) {
            colorIdx = lineIdx % colorMapRGB.length;
            yOffset = lineIdx * (hLetter + legendYSpacing) +  legendYSpacing;

            // create rectangle to capture mouse event
            var rectEl = createSVGElement("rect", {"id": "lri_"+lineIdx, "x":legendXSpacing, "y":yOffset,
                "width":wLegend, "height":hLetter + legendYSpacing, "fill":"none",
                "pointer-events":"visible", "onclick":"toggleLineVisibility(\""+lineIdx+"\",0)",
                "ondblclick":"toggleLineVisibility(\""+lineIdx+"\"," + legend.length + ")",
                "onscroll":"console.log('test')"
                });
                gcpleg.appendChild(rectEl);
        }

        var xLegend = 0;
        // update plot and legend dimensions depending on legend position
        switch(legendLocation) {
            case 'northeast':
                xLegend = plotAreaXOffset + plotWidth - wLegend - 2*legendXSpacing;
                break;
            case 'northeastoutside':
                xLegend = plotAreaXOffset + plotWidth - wLegend;
                plotWidth = plotWidth - wLegend - legendXSpacing;
                break;
            default:
                throw new Error("LegendLocation not supported");
        }

        // move legend to final location   
        gleg.setAttribute( "transform", "translate(" + xLegend +  " " + yLegend + ")");

    }   

    plotArea = [plotAreaXOffset, plotAreaYOffset, plotWidth, plotHeight];

    ///////////////////////////////
    // add title
    ///////////////////////////////
    var titleYOffset = 0;
    if(title.length>0) {
        for(idx = 0; idx < titleLines.length; ++idx) {
            titleYOffset = titleYOffset + titleFontSize + fontSpacing;
            appendSvgText(svg, titleLines[idx], plotArea[0] + plotArea[2]/2, titleYOffset, titleFontSize);
        };
    };  
    ///////////////////////////////
    // add subtitle
    ///////////////////////////////
    if(subtitle.length>0) {
        for(idx = 0; idx < subtitleLines.length; ++idx) {
            titleYOffset = titleYOffset + subTitleFontSize + fontSpacing;
            appendSvgText(svg, subtitleLines[idx], plotArea[0] + plotArea[2]/2, titleYOffset, subTitleFontSize);
        };    
    };

    ///////////////////////////////
    // draw xlabel
    ///////////////////////////////
    if(xlabel.length>0) {
        appendSvgText(svg, xlabel, plotArea[0] + plotArea[2]/2, plotArea[1] + plotArea[3] + axesLblFontSize*2.4 + fontSpacing, axesLblFontSize);
    };

    ///////////////////////////////
    // draw ylabel
    ///////////////////////////////
    if(ylabel.length>0) { 
        var text = createSVGElement("text", {"transform":"translate(" + (plotArea[0] - axesLblFontSize*4 - fontSpacing) + " " + (plotArea[1] + plotArea[3]/2) + ") rotate(270)",
        "fill":"black", "font-size":axesLblFontSize, "text-anchor":"middle", 
        "font-family":"Sans,Arial", "stroke-width": 1
        });  
        text.append(document.createTextNode(ylabel));
        svg.appendChild(text);  
    };

    ///////////////////////////////
    // Draw axes
    ///////////////////////////////
    // define range of plot
    var xMin = 0;
    var xMax = 0;
    var yMin = 0;
    var yMax = 0;

    if(xlim.length < 2) {
        xMin = Math.min(...x);
        xMax = Math.max(...x);
        if(xMin == NaN) {
        xMin = 0;
        xMax = 1;
        };
        if(xMin == xMax) {
        xMin = xMin - 0.5;
        xMax = xMax + 0.5;
        };
    } else {
        xMin = xlim[0];
        xMax = xlim[1];
    };
    if(ylim.length < 2) {
        yMin = Math.min(...y);
        yMax = Math.max(...y);

        if(yMin == NaN) {
            yMin = 0;
            yMax = 1;
        };
        if(yMin == yMax) {
            yMin = yMin - 0.5;
            yMax = yMax + 0.5;
        };
    } else {
        yMin = ylim[0];
        yMax = ylim[1];
    }


    //////////////////////////////
    // create clip path for plotting area
    //////////////////////////////
    var pBoxRec = createSVGElement("rect", {"x":plotArea[0],"y":plotArea[1],"width":plotArea[2],
        "height": plotArea[3],"fill": "url(#yTick_"+elementId+")"
    });

    var pBoxCp = createSVGElement("clipPath", {"id":"pBox_"+elementId});
    pBoxCp.appendChild(pBoxRec)
    svg.appendChild(pBoxCp);
    var pGrp = createSVGElement("g", {"clip-path":"url(#pBox_"+elementId+")"});
    svg.appendChild(pGrp);

    ////////////////////////////
    // Draw grid and labels
    ////////////////////////////
    var minorGridX = false;
    var minorGridY = false;
    if(gridMinor.length < 1) {
        // enable minor grid by default for log axes
        minorGridX = xScale == 'log';
        minorGridY = yScale == 'log';
    } else {
        minorGridX = gridMinor[0];
        if(gridMinor.length > 1)
            minorGridY = gridMinor[1];
        else
            minorGridY = gridMinor[1];
    }  
        

    var xTick = (xMax-xMin)/nXTicks;

    // round to next decade
    var exponent = Math.floor(Math.log10(xTick));
    var mantissa = Math.ceil(xTick/Math.pow(10,exponent));
    var normTickIdx=normTicks.findIndex(function(number) {
        return number >= mantissa;
    });
    var xTick = normTicks[normTickIdx] * Math.pow(10,exponent);

    if(logXEnbl) {
        if ((xMax-xMin) >= 1) { // keep 1 decade tick until there is at least 1 decade range
        xTick = xTick < 1 ? 1 : xTick;
        if(xTick > 1) {
            // log sub ticks only used for 1 decade range, higher ranges change to lin sub ticks
            // in that case each sub tick should be at least 1 decade
            nXMinorTicks = (xTick > nXMinorTicks) ? nXMinorTicks : xTick;
        }
        } else {
        nXMinorTicks = 0; // no sub ticks for less than 1 decade major tick range
        }
    } else {
        nXMinorTicks = 5; // 5 sub ticks for linear axes are cleaner than 10
    }

    var yTick = (yMax-yMin)/nYTicks;
    // round to next decade
    exponent = Math.floor(Math.log10(yTick));
    mantissa = Math.ceil(yTick/Math.pow(10,exponent));
    normTickIdx=normTicks.findIndex(function(number) {
        return number >= mantissa;
    });

    yTick = normTicks[normTickIdx] * Math.pow(10,exponent);
    if(logYEnbl) {
        if ((yMax-yMin) >= 1) { // keep 1 decade tick until there is at least 1 decade range
            yTick = yTick < 1 ? 1 : yTick;
            if(yTick > 1) {
                // log sub ticks only used for 1 decade range, higher ranges change to lin sub ticks
                // in that case each sub tick should be at least 1 decade
                nYMinorTicks = (yTick > nYMinorTicks) ? nYMinorTicks : yTick;
            }
        } else {
        nYMinorTicks = 0; // no sub ticks for less than 1 decade major tick range
        }
    } else {
        nYMinorTicks = 5; // 5 sub ticks for linear axes are cleaner than 10
    }
        
    if(xlim.length < 1) {
        if ((xMax-xMin)/xTick >= 4) {
        // change starting points based on tick
        xMin = Math.floor(xMin/xTick) * xTick;
        xMax = Math.ceil(xMax/xTick) * xTick;
        };
    };
    if(ylim.length < 1) {
        if((yMax-yMin)/yTick >= 4) {
            // change starting points based on tick
            yMin = Math.floor(yMin/yTick) * yTick;
            yMax = Math.ceil(yMax/yTick) * yTick;
        };
    };

    // next major ticks
    var xMinTick = Math.ceil(xMin/xTick) * xTick;
    var xMaxTick = Math.floor(xMax/xTick) * xTick;
    var yMinTick = Math.ceil(yMin/yTick) * yTick;
    var yMaxTick = Math.floor(yMax/yTick) * yTick;

    // offset in the plot in pixel
    var xTickOffset = plotArea[2] * (xMinTick - xMin)/(xMax-xMin);
    var yTickOffset = plotArea[3] * (yMaxTick - yMax)/(yMax-yMin);


    // actual number of ticks
    nXTicks = Math.round((xMaxTick-xMinTick)/xTick); // rounding should not be required, just put in case of small numerical errors
    nYTicks = Math.round((yMaxTick-yMinTick)/yTick); // rounding should not be required, just put in case of small numerical errors

    var tickLength = (plotArea[2] > plotArea[3]) ? plotArea[2] / 100 : plotArea[3] / 100;
    var minorTickLength = tickLength/2;



    if(logXEnbl) {
        xTickLabel = num2eng(decades(xMinTick,xTick,xMaxTick));
    } else {
        xTickLabel = num2eng(linspace(xMinTick,xTick,xMaxTick));
    };


    if(logYEnbl) {
        yTickLabel = num2eng(decades(yMinTick,yTick,yMaxTick));
    } else {
        yTickLabel = num2eng(linspace(yMinTick,yTick,yMaxTick));
    };
        
    // draw x ticks, labels and grid lines
    dXTick = plotArea[2] * xTick/(xMax-xMin); 

    // draw y tick, labels and grid lines
    dYTick = plotArea[3] * yTick/(yMax-yMin); 

    // axis labels
    for(idx = 0; idx <= nYTicks; ++idx) {
        var yTickPos = plotArea[1]+axesLblFontSize/3 - yTickOffset + dYTick * idx;
        appendSvgText(svg, yTickLabel[nYTicks-idx], plotArea[0] - axesLblFontSize*0.5, yTickPos, axesLblFontSize, "end");
    }
    for(idx = 0; idx <= nXTicks; ++idx) {
        var xTickPos = plotArea[0] + dXTick * idx + xTickOffset;  
        appendSvgText(svg, xTickLabel[idx], xTickPos, plotArea[1]  + plotArea[3] + axesLblFontSize*1.4, axesLblFontSize);
    }

    // draw tick lines via pattern (in case we use custom ticks, this cant
    // be used anymore, see below's loop then for an alternative)
    var defsgy = document.createElementNS(ns, "defs");
    pGrp.appendChild(defsgy);
    if(minorGridY && nYMinorTicks > 0) {
        var mgy = createSVGElement("g", { "id": "mgy_"+elementId});
        if(grid) {
        appendSvgLine(mgy, 0, 1, plotArea[2],1, stroke="rgb(223,223,223)", strokedasharray="2 4");
        };
        appendSvgLine(mgy, 0, 1, minorTickLength,1);
        appendSvgLine(mgy, plotArea[2] - minorTickLength, 1, plotArea[2], 1);
        defsgy.appendChild(mgy);
    };

    var py = createSVGElement('pattern', {"id":"yTick_"+elementId, "x":plotArea[0], 
        "y":plotArea[1]-yTickOffset-1, "width": plotArea[2], "height": dYTick,
        "patternUnits": "userSpaceOnUse"
        });
    defsgy.appendChild(py);

    if(minorGridY && nYMinorTicks > 0) {
        if(logYEnbl && yTick == 1) {
        minorTickPos = logspace(1, (9/(nYMinorTicks-1)), 10);
        minorTickPos.forEach((value, index) => {minorTickPos[index] = (1-minorTickPos[index])*dYTick});
        } else {
        minorTickPos = linspace(0, (1/nYMinorTicks)*dYTick, dYTick);
        };
        for(idx = 1; idx < minorTickPos.length-1; ++idx) {
        var usey = createSVGElement('use', {"href":"#mgy_"+elementId, "y":minorTickPos[idx]});
        py.append(usey);
        };
    };
    if(grid) {
        appendSvgLine(py, 0, 1, plotArea[2],1, stroke="rgb(223,223,223)");
    };
    appendSvgLine(py, 0, 1, tickLength,1);
    appendSvgLine(py, plotArea[2] - tickLength, 1, plotArea[2], 1);
    var pyr = createSVGElement("rect", {"x":plotArea[0],"y":plotArea[1],"width":plotArea[2],
        "height": plotArea[3],"fill": "url(#yTick_"+elementId+")"
    });
    pGrp.appendChild(pyr);

    // draw tick lines via pattern (in case we use custom ticks, this cant
    // be used anymore, see below's loop then for an alternative)
    var defsgx = document.createElementNS(ns, "defs");
    pGrp.appendChild(defsgx);
    if(minorGridX && nXMinorTicks > 0) {
        var mgx = createSVGElement("g", { "id": "mgx_"+elementId});
        if(grid) {
        appendSvgLine(mgx, 1, 0, 1, plotArea[3], stroke="rgb(223,223,223)", strokedasharray="2 4");
        };
        appendSvgLine(mgx, 1, 0, 1, minorTickLength);
        appendSvgLine(mgx, 1, plotArea[3] - minorTickLength, 1, plotArea[3]);
        defsgx.appendChild(mgx);
    };

    var px = createSVGElement('pattern', {"id":"xTick_"+elementId, "x":plotArea[0]+xTickOffset-1, 
        "y":plotArea[1], "width": dXTick, "height": plotArea[3],
        "patternUnits": "userSpaceOnUse"
        });
    defsgx.appendChild(px);

    if(minorGridX && nXMinorTicks > 0) {
        if(logXEnbl && xTick == 1) {
        minorTickPos = logspace(1, (9/(nXMinorTicks-1)), 10);
        minorTickPos.forEach((value, index) => {minorTickPos[index] *= dXTick});
        } else {
        minorTickPos = linspace(0, (1/nXMinorTicks)*dXTick, dXTick);
        };
        for(idx = 1; idx < minorTickPos.length-1; ++idx) {
        var usex = createSVGElement('use', {"href":"#mgx_"+elementId, "x":minorTickPos[idx]});
        px.append(usex);
        };
    };
    if(grid) {
        appendSvgLine(px, 1, 0, 1, plotArea[3], stroke="rgb(223,223,223)");
    };
    appendSvgLine(px, 1, 0, 1, tickLength);
    appendSvgLine(px, 1, plotArea[3] - tickLength, 1, plotArea[3]);

    var pxr = createSVGElement("rect", {"x":plotArea[0],"y":plotArea[1],"width":plotArea[2],
        "height": plotArea[3],"fill": "url(#xTick_"+elementId+")"
    });
    pGrp.appendChild(pxr);


    //////////////////////////////
    // create polylines
    //////////////////////////////
    var numPtPerLine = y.length / numLines;
    var varX = x.length == y.length;
    if(!varX && (numPtPerLine != x.length))
        throw new Error("Dimension must agree");

    for(lineIdx = 0; lineIdx < numLines; ++lineIdx) {
        var xLen = x.length;
        var pointArray = new Array(xLen*2);
        colorIdx = lineIdx % colorMapRGB.length;
        for(ptIdx = 0; ptIdx < numPtPerLine; ++ptIdx) {
        var ptx = varX ? x[lineIdx*numPtPerLine  + ptIdx] : x[ptIdx];
        var pty = y[lineIdx*numPtPerLine  + ptIdx];
        pointArray[2*ptIdx] = plotArea[0] + plotArea[2] * (ptx-xMin) / (xMax-xMin);
        pointArray[2*ptIdx+1] = plotArea[1] + plotArea[3] - plotArea[3]*(pty-yMin) / (yMax-yMin);
        };

        var poly = document.createElementNS(ns, "polyline");
        //rect.setAttributeNS(null, 'class', "pl")
        poly.setAttribute("id", "pl_" + lineIdx);
        poly.setAttribute("points", pointArray.join(" "));
        poly.setAttribute("stroke", colorMapRGB[colorIdx]);
        poly.setAttribute("stroke-width", 1.5);
        poly.setAttribute("fill", "none");
        pGrp.appendChild(poly);
    };

    //////////////////////////////
    // create drawing area
    //////////////////////////////
    var rect = createSVGElement("rect", {"x":plotArea[0],"y":plotArea[1],"width":plotArea[2],
        "height": plotArea[3],"fill": "none","stroke":"black","stroke-width": 1
    });
    svg.appendChild(rect);

    // add legend last
    //svg.appendChild(gleg); 
    svg.appendChild(gleg);
};
